import { readFileSync, promises } from 'fs';
import { globby } from 'globby';
import { resolve, parse } from 'pathe';
import { findStaticImports, parseStaticImport, findExports, detectSyntax } from 'mlly';
import { camelCase } from 'scule';
import MagicString from 'magic-string';
import { resolveModule } from 'local-pkg';

const excludeRE = [
  /\bimport\s*([\s\S]+?)\s*from\b/g,
  /\bfunction\s*([\w_$]+?)\s*\(/g,
  /\b(?:const|let|var)\s+?(\[[\s\S]*?\]|\{[\s\S]*?\}|[\s\S]+?)\s*?[=;\n]/g
];
const importAsRE = /^.*\sas\s+/;
const separatorRE = /[,[\]{}\n]/g;
const matchRE = /(?:\b|^)([\w_$]+)\s*(?:[.()[\];+*&|`<>,-])/g;
const regexRE = /\/.*?(?<!\\)\/[gimsuy]*/g;
const multilineCommentsRE = /\/\*\s(.|[\r\n])*?\*\//gm;
const singlelineCommentsRE = /\/\/\s.*$/gm;
const templateLiteralRE = /\$\{(.*?)\}/g;
const quotesRE = [
  /(["'])((?:\\\1|(?!\1)|.|\r)*?)\1/gm,
  /([`])((?:\\\1|(?!\1)|.|\n|\r)*?)\1/gm
];
function defineUnimportPreset(preset) {
  return preset;
}
function stripCommentsAndStrings(code) {
  return code.replace(multilineCommentsRE, "").replace(singlelineCommentsRE, "").replace(templateLiteralRE, "` + $1 + `").replace(quotesRE[0], '""').replace(quotesRE[1], "``").replace(regexRE, 'new RegExp("")');
}
function toImports(imports, isCJS = false) {
  const map = toImportModuleMap(imports);
  return Object.entries(map).flatMap(([name, importSet]) => {
    const entries = [];
    const imports2 = Array.from(importSet).filter((i) => {
      if (i.name === "default") {
        entries.push(isCJS ? `const { default: ${i.as} } = require('${name}');` : `import ${i.as} from '${name}';`);
        return false;
      } else if (i.name === "*") {
        entries.push(isCJS ? `const ${i.as} = require('${name}');` : `import * as ${i.as} from '${name}';`);
        return false;
      }
      return true;
    });
    if (imports2.length) {
      const importsAs = imports2.map((i) => stringifyImportAlias(i, isCJS));
      entries.push(isCJS ? `const { ${importsAs.join(", ")} } = require('${name}');` : `import { ${importsAs.join(", ")} } from '${name}';`);
    }
    return entries;
  }).join("\n");
}
function dedupeImports(imports, warn) {
  const map = /* @__PURE__ */ new Map();
  const indexToRemove = /* @__PURE__ */ new Set();
  imports.filter((i) => !i.disabled).forEach((i, idx) => {
    const name = i.as || i.name;
    if (!map.has(name)) {
      map.set(name, idx);
      return;
    }
    const other = imports[map.get(name)];
    if (other.from === i.from) {
      indexToRemove.add(idx);
      return;
    }
    const diff = (other.priority || 1) - (i.priority || 1);
    if (diff === 0) {
      warn(`Duplicated imports "${name}", the one from "${other.from}" has been ignored`);
    }
    if (diff <= 0) {
      indexToRemove.add(map.get(name));
      map.set(name, idx);
    } else {
      indexToRemove.add(idx);
    }
  });
  return imports.filter((_, idx) => !indexToRemove.has(idx));
}
function toExports(imports) {
  const map = toImportModuleMap(imports);
  return Object.entries(map).flatMap(([name, imports2]) => {
    name = name.replace(/\.[a-z]+$/, "");
    const entries = [];
    const filtered = Array.from(imports2).filter((i) => {
      if (i.name === "*") {
        entries.push(`export * as ${i.as} from '${name}';`);
        return false;
      }
      return true;
    });
    if (filtered.length) {
      entries.push(`export { ${filtered.map((i) => stringifyImportAlias(i, false)).join(", ")} } from '${name}';`);
    }
    return entries;
  }).join("\n");
}
function toTypeDeclrationItems(imports, options) {
  return imports.map((i) => {
    const from = options?.resolvePath?.(i) || i.from;
    return `const ${i.as}: typeof import('${from}')${i.name !== "*" ? `['${i.name}']` : ""}`;
  });
}
function toTypeDeclrationFile(imports, options) {
  const items = toTypeDeclrationItems(imports, options);
  const {
    exportHelper = true
  } = options || {};
  let declration = "";
  if (exportHelper) {
    declration += "export {}\n";
  }
  declration += "declare global {\n" + items.map((i) => "  " + i).join("\n") + "\n}";
  return declration;
}
function stringifyImportAlias(item, isCJS = false) {
  return item.as === void 0 || item.name === item.as ? item.name : isCJS ? `${item.name}: ${item.as}` : `${item.name} as ${item.as}`;
}
function toImportModuleMap(imports) {
  const map = {};
  for (const _import of imports) {
    if (!map[_import.from]) {
      map[_import.from] = /* @__PURE__ */ new Set();
    }
    map[_import.from].add(_import);
  }
  return map;
}
function getString(code) {
  if (typeof code === "string") {
    return code;
  }
  return code.toString();
}
function getMagicString(code) {
  if (typeof code === "string") {
    return new MagicString(code);
  }
  return code;
}
function addImportToCode(code, imports, isCJS = false, mergeExisting = false) {
  let newImports = [];
  const s = getMagicString(code);
  if (mergeExisting && !isCJS) {
    const existing = findStaticImports(s.original).map((i) => parseStaticImport(i));
    const map = /* @__PURE__ */ new Map();
    imports.forEach((i) => {
      const target = existing.find((e) => e.specifier === i.from && e.imports.startsWith("{"));
      if (!target) {
        return newImports.push(i);
      }
      if (!map.has(target)) {
        map.set(target, []);
      }
      map.get(target).push(i);
    });
    for (const [target, items] of map.entries()) {
      const strings = items.map((i) => stringifyImportAlias(i) + ", ");
      const importLength = target.code.match(/^\s*import\s*{/)?.[0]?.length;
      if (importLength) {
        s.appendLeft(target.start + importLength, " " + strings.join("").trim());
      }
    }
  } else {
    newImports = imports;
  }
  const newEntries = toImports(newImports, isCJS);
  if (newEntries) {
    s.prepend(newEntries);
  }
  return {
    s,
    code: s.toString()
  };
}
function normalizeImports(imports) {
  for (const _import of imports) {
    _import.as = _import.as || _import.name;
  }
  return imports;
}

const pinia = defineUnimportPreset({
  from: "pinia",
  imports: [
    "acceptHMRUpdate",
    "createPinia",
    "defineStore",
    "getActivePinia",
    "mapActions",
    "mapGetters",
    "mapState",
    "mapStores",
    "mapWritableState",
    "setActivePinia",
    "setMapStoreSuffix",
    "storeToRefs"
  ]
});

const preact = defineUnimportPreset({
  from: "preact",
  imports: [
    "useState",
    "useCallback",
    "useMemo",
    "useEffect",
    "useRef",
    "useContext",
    "useReducer"
  ]
});

const quasar = defineUnimportPreset({
  from: "quasar",
  imports: [
    "useQuasar",
    "useDialogPluginComponent",
    "useFormChild",
    "useMeta"
  ]
});

const react = defineUnimportPreset({
  from: "react",
  imports: [
    "useState",
    "useCallback",
    "useMemo",
    "useEffect",
    "useRef",
    "useContext",
    "useReducer"
  ]
});

const ReactRouterHooks = [
  "useOutletContext",
  "useHref",
  "useInRouterContext",
  "useLocation",
  "useNavigationType",
  "useNavigate",
  "useOutlet",
  "useParams",
  "useResolvedPath",
  "useRoutes"
];
const reactRouter = defineUnimportPreset({
  from: "react-router",
  imports: [
    ...ReactRouterHooks
  ]
});

const reactRouterDom = defineUnimportPreset({
  from: "react-router-dom",
  imports: [
    ...ReactRouterHooks,
    "useLinkClickHandler",
    "useSearchParams",
    "Link",
    "NavLink",
    "Navigate",
    "Outlet",
    "Route",
    "Routes"
  ]
});

const svelteAnimate = defineUnimportPreset({
  from: "svelte/animate",
  imports: [
    "flip"
  ]
});
const svelteEasing = defineUnimportPreset({
  from: "svelte/easing",
  imports: [
    "back",
    "bounce",
    "circ",
    "cubic",
    "elastic",
    "expo",
    "quad",
    "quart",
    "quint",
    "sine"
  ].reduce((acc, e) => {
    acc.push(`${e}In`, `${e}Out`, `${e}InOut`);
    return acc;
  }, ["linear"])
});
const svelteStore = defineUnimportPreset({
  from: "svelte/store",
  imports: [
    "writable",
    "readable",
    "derived",
    "get"
  ]
});
const svelteMotion = defineUnimportPreset({
  from: "svelte/motion",
  imports: [
    "tweened",
    "spring"
  ]
});
const svelteTransition = defineUnimportPreset({
  from: "svelte/transition",
  imports: [
    "fade",
    "blur",
    "fly",
    "slide",
    "scale",
    "draw",
    "crossfade"
  ]
});
const svelte = defineUnimportPreset({
  from: "svelte",
  imports: [
    "onMount",
    "beforeUpdate",
    "afterUpdate",
    "onDestroy",
    "tick",
    "setContext",
    "getContext",
    "hasContext",
    "getAllContexts",
    "createEventDispatcher"
  ]
});

const veeValidate = defineUnimportPreset({
  from: "vee-validate",
  imports: [
    "validate",
    "defineRule",
    "configure",
    "useField",
    "useForm",
    "useFieldArray",
    "useResetForm",
    "useIsFieldDirty",
    "useIsFieldTouched",
    "useIsFieldValid",
    "useIsSubmitting",
    "useValidateField",
    "useIsFormDirty",
    "useIsFormTouched",
    "useIsFormValid",
    "useValidateForm",
    "useSubmitCount",
    "useFieldValue",
    "useFormValues",
    "useFormErrors",
    "useFieldError",
    "useSubmitForm",
    "FormContextKey",
    "FieldContextKey"
  ]
});

const vitepress = defineUnimportPreset({
  from: "vitepress",
  imports: [
    "useData",
    "useRoute",
    "useRouter",
    "withBase"
  ]
});

const CommonCompositionAPI = [
  "onActivated",
  "onBeforeMount",
  "onBeforeUnmount",
  "onBeforeUpdate",
  "onErrorCaptured",
  "onDeactivated",
  "onMounted",
  "onServerPrefetch",
  "onUnmounted",
  "onUpdated",
  "useAttrs",
  "useSlots",
  "computed",
  "customRef",
  "isReadonly",
  "isRef",
  "markRaw",
  "reactive",
  "readonly",
  "ref",
  "shallowReactive",
  "shallowReadonly",
  "shallowRef",
  "triggerRef",
  "toRaw",
  "toRef",
  "toRefs",
  "unref",
  "watch",
  "watchEffect",
  "defineComponent",
  "defineAsyncComponent",
  "getCurrentInstance",
  "h",
  "inject",
  "nextTick",
  "provide",
  "useCssModule",
  "createApp",
  "effectScope",
  "EffectScope",
  "getCurrentScope",
  "onScopeDispose"
];
const vue = defineUnimportPreset({
  from: "vue",
  imports: [
    ...CommonCompositionAPI,
    "onRenderTracked",
    "onRenderTriggered",
    "resolveComponent",
    "useCssVars"
  ]
});

const vueMacros = defineUnimportPreset({
  from: "vue/macros",
  imports: [
    "$",
    "$$",
    "$ref",
    "$shallowRef",
    "$toRef",
    "$customRef",
    "$computed"
  ]
});

const vueDemi = defineUnimportPreset({
  from: "vue-demi",
  imports: CommonCompositionAPI
});

const vueI18n = defineUnimportPreset({
  from: "vue-i18n",
  imports: [
    "useI18n"
  ]
});

const vueRouter = defineUnimportPreset({
  from: "vue-router",
  imports: [
    "useRouter",
    "useRoute"
  ]
});

const vueCompositionApi = defineUnimportPreset({
  from: "@vue/composition-api",
  imports: CommonCompositionAPI
});

let _cache;
const vueuseCore = () => {
  const excluded = ["toRefs", "utils"];
  if (!_cache) {
    try {
      const path = resolveModule("@vueuse/core/indexes.json");
      const indexesJson = JSON.parse(readFileSync(path, "utf-8"));
      _cache = defineUnimportPreset({
        from: "@vueuse/core",
        imports: indexesJson.functions.filter((i) => ["core", "shared"].includes(i.package)).map((i) => i.name).filter((i) => i && i.length >= 4 && !excluded.includes(i))
      });
    } catch (error) {
      console.error(error);
      throw new Error("[auto-import] failed to load @vueuse/core, have you installed it?");
    }
  }
  return _cache;
};

const vueuseHead = defineUnimportPreset({
  from: "@vueuse/head",
  imports: [
    "useHead"
  ]
});

const vuex = defineUnimportPreset({
  from: "vuex",
  imports: [
    "createStore",
    "createLogger",
    "mapState",
    "mapGetters",
    "mapActions",
    "mapMutations",
    "createNamespacedHelpers",
    "useStore"
  ]
});

const vitest = defineUnimportPreset({
  from: "vitest",
  imports: [
    "suite",
    "test",
    "describe",
    "it",
    "chai",
    "expect",
    "assert",
    "vitest",
    "vi",
    "beforeAll",
    "afterAll",
    "beforeEach",
    "afterEach"
  ]
});

const uniApp = defineUnimportPreset({
  from: "@dcloudio/uni-app",
  imports: [
    "onAddToFavorites",
    "onBackPress",
    "onError",
    "onHide",
    "onLaunch",
    "onLoad",
    "onNavigationBarButtonTap",
    "onNavigationBarSearchInputChanged",
    "onNavigationBarSearchInputClicked",
    "onNavigationBarSearchInputConfirmed",
    "onNavigationBarSearchInputFocusChanged",
    "onPageNotFound",
    "onPageScroll",
    "onPullDownRefresh",
    "onReachBottom",
    "onReady",
    "onResize",
    "onShareAppMessage",
    "onShareTimeline",
    "onShow",
    "onTabItemTap",
    "onThemeChange",
    "onUnhandledRejection",
    "onUnload"
  ]
});

const solidCore = defineUnimportPreset({
  from: "solid-js",
  imports: [
    "createSignal",
    "createEffect",
    "createMemo",
    "createResource",
    "onMount",
    "onCleanup",
    "onError",
    "untrack",
    "batch",
    "on",
    "createRoot",
    "mergeProps",
    "splitProps",
    "useTransition",
    "observable",
    "mapArray",
    "indexArray",
    "createContext",
    "useContext",
    "children",
    "lazy",
    "createDeferred",
    "createRenderEffect",
    "createSelector",
    "For",
    "Show",
    "Switch",
    "Match",
    "Index",
    "ErrorBoundary",
    "Suspense",
    "SuspenseList"
  ]
});
const solidStore = defineUnimportPreset({
  from: "solid-js/store",
  imports: [
    "createStore",
    "produce",
    "reconcile",
    "createMutable"
  ]
});
const solidWeb = defineUnimportPreset({
  from: "solid-js/web",
  imports: [
    "Dynamic",
    "hydrate",
    "render",
    "renderToString",
    "renderToStringAsync",
    "renderToStream",
    "isServer",
    "Portal"
  ]
});
const solid = defineUnimportPreset({
  from: "solid-js",
  imports: [
    solidCore,
    solidStore,
    solidWeb
  ]
});

const solidAppRouter = defineUnimportPreset({
  from: "solid-app-router",
  imports: [
    "Link",
    "NavLink",
    "Navigate",
    "Outlet",
    "Route",
    "Router",
    "Routes",
    "_mergeSearchString",
    "createIntegration",
    "hashIntegration",
    "normalizeIntegration",
    "pathIntegration",
    "staticIntegration",
    "useHref",
    "useIsRouting",
    "useLocation",
    "useMatch",
    "useNavigate",
    "useParams",
    "useResolvedPath",
    "useRouteData",
    "useRoutes",
    "useSearchParams"
  ]
});

const builtinPresets = {
  "@vue/composition-api": vueCompositionApi,
  "@vueuse/core": vueuseCore,
  "@vueuse/head": vueuseHead,
  pinia,
  preact,
  quasar,
  react,
  "react-router": reactRouter,
  "react-router-dom": reactRouterDom,
  svelte,
  "svelte/animate": svelteAnimate,
  "svelte/easing": svelteEasing,
  "svelte/motion": svelteMotion,
  "svelte/store": svelteStore,
  "svelte/transition": svelteTransition,
  "vee-validate": veeValidate,
  vitepress,
  "vue-demi": vueDemi,
  "vue-i18n": vueI18n,
  "vue-router": vueRouter,
  vue,
  "vue/macros": vueMacros,
  vuex,
  vitest,
  "uni-app": uniApp,
  "solid-js": solid,
  "solid-app-router": solidAppRouter
};

const commonProps = ["from", "priority", "disabled"];
function resolvePreset(preset) {
  const imports = [];
  const common = {};
  commonProps.forEach((i) => {
    if (i in preset) {
      common[i] = preset[i];
    }
  });
  for (const _import of preset.imports) {
    if (typeof _import === "string") {
      imports.push({ ...common, name: _import, as: _import });
    } else if (Array.isArray(_import)) {
      imports.push({ ...common, name: _import[0], as: _import[1] || _import[0], from: _import[2] || preset.from });
    } else if (_import.imports) {
      imports.push(...resolvePreset(_import));
    } else {
      imports.push({ ...common, ..._import });
    }
  }
  return imports;
}
function resolveBuiltinPresets(presets) {
  return presets.flatMap((p) => {
    let preset = typeof p === "string" ? builtinPresets[p] : p;
    if (typeof preset === "function") {
      preset = preset();
    }
    return resolvePreset(preset);
  });
}

async function resolveFiles(path, pattern) {
  const files = await globby(pattern, { cwd: path, followSymbolicLinks: true });
  return files.map((p) => resolve(path, p));
}
async function scanDirExports(dir, options) {
  const dirs = Array.isArray(dir) ? dir : [dir];
  const fileFilter = options?.fileFilter || (() => true);
  const files = await Promise.all(dirs.map((i) => resolveFiles(i, [
    "*.{ts,js,mjs,cjs,mts,cts}",
    "*/index.{ts,js,mjs,cjs,mts,cts}"
  ]))).then((r) => r.flat().filter(fileFilter));
  const imports = [];
  await Promise.all(files.map(async (path) => {
    imports.push(...await scanExports(path));
  }));
  return imports;
}
async function scanExports(filepath) {
  const imports = [];
  const code = await promises.readFile(filepath, "utf-8");
  const exports = findExports(code);
  const defaultExport = exports.find((i) => i.type === "default");
  if (defaultExport) {
    let name = parse(filepath).name;
    if (name === "index") {
      name = parse(filepath.split("/").slice(0, -1).join("/")).name;
    }
    imports.push({ name: "default", as: camelCase(name), from: filepath });
  }
  for (const exp of exports) {
    if (exp.type === "named") {
      for (const name of exp.names) {
        imports.push({ name, as: name, from: filepath });
      }
    } else if (exp.type === "declaration") {
      if (exp.name) {
        imports.push({ name: exp.name, as: exp.name, from: filepath });
      }
    }
  }
  return imports;
}

const contextRE = /\b_ctx\.([\w_]+)\b/g;
const vueTemplateAddon = {
  transform(s, _, ctx) {
    if (!s.original.includes("_ctx.")) {
      return s;
    }
    const matches = Array.from(s.original.matchAll(contextRE));
    if (!matches.length) {
      return s;
    }
    const imports = ctx.imports;
    const targets = [];
    for (const match of matches) {
      const name = match[1];
      const item = imports.find((i) => i.as === name);
      if (!item) {
        continue;
      }
      const start = match.index;
      const end = start + match[0].length;
      const tempName = "__unimport_" + name;
      s.overwrite(start, end, tempName);
      if (!targets.find((i) => i.as === tempName)) {
        targets.push({
          ...item,
          as: tempName
        });
      }
    }
    if (targets.length) {
      s.prepend(toImports(targets));
    }
    return s;
  },
  decleration(dts, ctx, options) {
    const items = toTypeDeclrationItems(ctx.imports, options).map((i) => i.replace("const ", ""));
    return dts + `
// for vue template auto import
declare module 'vue' {
  interface ComponentCustomProperties {
${items.map((i) => "    " + i).join("\n")}
  }
}
`;
  }
};
const vueTemplateAddon$1 = vueTemplateAddon;

function createUnimport(opts) {
  let _combinedImports;
  const addons = [];
  if (opts.addons?.vueTemplate) {
    addons.push(vueTemplateAddon$1);
  }
  const ctx = {
    staticImports: [...opts.imports || []].filter(Boolean),
    dynamicImports: [],
    get imports() {
      if (!_combinedImports) {
        _combinedImports = reload();
      }
      return _combinedImports;
    },
    addons,
    map: /* @__PURE__ */ new Map()
  };
  ctx.staticImports.push(...resolveBuiltinPresets(opts.presets || []));
  function reload() {
    const imports = normalizeImports(dedupeImports([...ctx.staticImports, ...ctx.dynamicImports], opts.warn || console.warn)).filter((i) => !i.disabled);
    ctx.map.clear();
    for (const _import of imports) {
      ctx.map.set(_import.as ?? _import.name, _import);
    }
    return imports;
  }
  async function modifyDynamicImports(fn) {
    await fn(ctx.dynamicImports);
    _combinedImports = void 0;
  }
  function clearDynamicImports() {
    ctx.dynamicImports.length = 0;
  }
  function generateTypeDecarations(options) {
    const opts2 = {
      resolvePath: (i) => i.from.replace(/\.ts$/, ""),
      ...options
    };
    let dts = toTypeDeclrationFile(ctx.imports, opts2);
    for (const addon of ctx.addons) {
      dts = addon.decleration?.(dts, ctx, opts2) ?? dts;
    }
    return dts;
  }
  reload();
  return {
    clearDynamicImports,
    modifyDynamicImports,
    getImports: () => ctx.imports,
    detectImports: (code) => detectImports(code, ctx),
    injectImports: (code, id, options) => injectImports(code, id, ctx, options),
    toExports: () => toExports(ctx.imports),
    generateTypeDecarations
  };
}
async function detectImports(code, ctx) {
  const strippedCode = stripCommentsAndStrings(getString(code));
  const isCJSContext = detectSyntax(strippedCode).hasCJS;
  const matched = new Set(Array.from(strippedCode.matchAll(matchRE)).map((i) => i[1]));
  for (const regex of excludeRE) {
    Array.from(strippedCode.matchAll(regex)).flatMap((i) => [
      ...i[1]?.split(separatorRE) || [],
      ...i[2]?.split(separatorRE) || []
    ]).map((i) => i.replace(importAsRE, "").trim()).forEach((i) => matched.delete(i));
  }
  const matchedImports = Array.from(matched).map((name) => ctx.map.get(name)).filter((i) => i && !i.disabled);
  return {
    strippedCode,
    isCJSContext,
    matchedImports
  };
}
async function injectImports(code, id, ctx, options) {
  const s = getMagicString(code);
  for (const addon of ctx.addons) {
    await addon.transform(s, id, ctx);
  }
  const { isCJSContext, matchedImports } = await detectImports(s, ctx);
  return addImportToCode(s, matchedImports, isCJSContext, options?.mergeExisting);
}

export { resolveBuiltinPresets as a, builtinPresets as b, stripCommentsAndStrings as c, defineUnimportPreset as d, excludeRE as e, dedupeImports as f, toExports as g, toTypeDeclrationItems as h, importAsRE as i, toTypeDeclrationFile as j, getString as k, getMagicString as l, matchRE as m, addImportToCode as n, normalizeImports as o, resolveFiles as p, scanDirExports as q, resolvePreset as r, separatorRE as s, toImports as t, scanExports as u, createUnimport as v };
