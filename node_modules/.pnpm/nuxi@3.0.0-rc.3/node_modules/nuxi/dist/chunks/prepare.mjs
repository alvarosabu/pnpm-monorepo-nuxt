import { promises } from 'node:fs';
import { a as relative, j as join, i as isAbsolute, r as resolve } from './index3.mjs';
import { g as getModulePaths, a as getNearestPackage } from './cjs.mjs';

function isObject(val) {
  return val !== null && typeof val === "object";
}
function _defu(baseObj, defaults, namespace = ".", merger) {
  if (!isObject(defaults)) {
    return _defu(baseObj, {}, namespace, merger);
  }
  const obj = Object.assign({}, defaults);
  for (const key in baseObj) {
    if (key === "__proto__" || key === "constructor") {
      continue;
    }
    const val = baseObj[key];
    if (val === null || val === void 0) {
      continue;
    }
    if (merger && merger(obj, key, val, namespace)) {
      continue;
    }
    if (Array.isArray(val) && Array.isArray(obj[key])) {
      obj[key] = val.concat(obj[key]);
    } else if (isObject(val) && isObject(obj[key])) {
      obj[key] = _defu(val, obj[key], (namespace ? `${namespace}.` : "") + key.toString(), merger);
    } else {
      obj[key] = val;
    }
  }
  return obj;
}
function createDefu(merger) {
  return (...args) => args.reduce((p, c) => _defu(p, c, "", merger), {});
}
const defu = createDefu();

const writeTypes = async (nuxt) => {
  const modulePaths = getModulePaths(nuxt.options.modulesDir);
  const tsConfig = defu(nuxt.options.typescript?.tsConfig, {
    compilerOptions: {
      jsx: "preserve",
      target: "ESNext",
      module: "ESNext",
      moduleResolution: "Node",
      skipLibCheck: true,
      strict: nuxt.options.typescript?.strict ?? false,
      allowJs: true,
      noEmit: true,
      resolveJsonModule: true,
      allowSyntheticDefaultImports: true,
      types: ["node"],
      baseUrl: relative(nuxt.options.buildDir, nuxt.options.rootDir),
      paths: {}
    },
    include: [
      "./nuxt.d.ts",
      join(relative(nuxt.options.buildDir, nuxt.options.rootDir), "**/*"),
      ...nuxt.options.srcDir !== nuxt.options.rootDir ? [join(relative(nuxt.options.buildDir, nuxt.options.srcDir), "**/*")] : []
    ]
  });
  const aliases = {
    ...nuxt.options.alias,
    "#build": nuxt.options.buildDir
  };
  const excludedAlias = [/^@vue\/.*$/];
  for (const alias in aliases) {
    if (excludedAlias.some((re) => re.test(alias))) {
      continue;
    }
    const relativePath = isAbsolute(aliases[alias]) ? relative(nuxt.options.rootDir, aliases[alias]) || "." : aliases[alias];
    const stats = await promises.stat(resolve(nuxt.options.rootDir, relativePath)).catch(() => null);
    if (stats?.isDirectory()) {
      tsConfig.compilerOptions.paths[alias] = [relativePath];
      tsConfig.compilerOptions.paths[`${alias}/*`] = [`${relativePath}/*`];
    } else {
      tsConfig.compilerOptions.paths[alias] = [relativePath.replace(/(?<=\w)\.\w+$/g, "")];
    }
  }
  const references = [
    ...nuxt.options.buildModules,
    ...nuxt.options.modules,
    ...nuxt.options._modules
  ].filter((f) => typeof f === "string").map((id) => ({ types: getNearestPackage(id, modulePaths)?.name || id }));
  if (nuxt.options.experimental?.reactivityTransform) {
    references.push({ types: "vue/macros-global" });
  }
  const declarations = [];
  await nuxt.callHook("prepare:types", { references, declarations, tsConfig });
  const declaration = [
    ...references.map((ref) => {
      if ("path" in ref && isAbsolute(ref.path)) {
        ref.path = relative(nuxt.options.buildDir, ref.path);
      }
      return `/// <reference ${renderAttrs(ref)} />`;
    }),
    ...declarations,
    "",
    "export {}",
    ""
  ].join("\n");
  async function writeFile() {
    const GeneratedBy = "// Generated by nuxi";
    const tsConfigPath = resolve(nuxt.options.buildDir, "tsconfig.json");
    await promises.mkdir(nuxt.options.buildDir, { recursive: true });
    await promises.writeFile(tsConfigPath, GeneratedBy + "\n" + JSON.stringify(tsConfig, null, 2));
    const declarationPath = resolve(nuxt.options.buildDir, "nuxt.d.ts");
    await promises.writeFile(declarationPath, GeneratedBy + "\n" + declaration);
  }
  nuxt.hook("builder:prepared", writeFile);
  await writeFile();
};
function renderAttrs(obj) {
  return Object.entries(obj).map((e) => renderAttr(e[0], e[1])).join(" ");
}
function renderAttr(key, value) {
  return value ? `${key}="${value}"` : "";
}

export { defu as d, writeTypes as w };
